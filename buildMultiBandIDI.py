#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Given a collection of .npz files create a FITS-IDI file that can be read in by
AIPS.

$Rev$
$LastChangedBy$
$LastChangedDate$
"""

import os
import re
import sys
import time
import ephem
import numpy
import getopt
import tempfile
from datetime import datetime, timedelta, tzinfo

from lsl import astro
from lsl.common import stations, metabundle
from lsl.statistics import robust
from lsl.correlator import uvUtils
from lsl.correlator import fx as fxc
#from lsl.writer import fitsidi
from lsl.correlator.uvUtils import computeUVW
from lsl.common.constants import c as vLight
from lsl.common.mcs import datetime2mjdmpm

from utils import readCorrelatorConfiguration

import fitsidi


def usage(exitCode=None):
	print """buildIDI.py - Given a collection of .npz files generated by "the next 
generation of correlator", create one or more FITS IDI files containing the
data.

Usage:
buildIDI.py [OPTIONS] npz [npz [...]]

Options:
-h, --help                  Display this help information
-c, --circular              Convert to circular
-k, --stokes                Convert to Stokes
-d, --decimate              Frequency decimation factor (default = 1)
-l, --limit                 Limit the data loaded to the first N files
                            (default = -1 = load all)
-s, --split                 Maximum number of integrations in a FITS IDI file
                            (default = 3000)
-t, --tag                   Optional tag to add to the filename
-f, --force                 Force overwriting of existing FITS-IDI files
"""
	
	if exitCode is not None:
		sys.exit(exitCode)
	else:
		return True


def parseConfig(args):
	config = {}
	# Command line flags - default values
	config['circular'] = False
	config['stokes'] = False
	config['freqDecimation'] = 1
	config['lastFile'] = -1
	config['maxIntsInIDI'] = 3000
	config['outnameTag'] = None
	config['force'] = False
	config['args'] = []
	
	# Read in and process the command line flags
	try:
		opts, args = getopt.getopt(args, "hckd:l:s:t:f", ["help", "circular", "stokes", "decimate=", "limit=", "split=", "tag=", "force"])
	except getopt.GetoptError, err:
		# Print help information and exit:
		print str(err) # will print something like "option -a not recognized"
		usage(exitCode=2)
		
	# Work through opts
	for opt, value in opts:
		if opt in ('-h', '--help'):
			usage(exitCode=0)
		elif opt in ('-c', '--circular'):
			config['circular'] = True
			config['stokes'] = False
		elif opt in ('-k', '--stokes'):
			config['circular'] = False
			config['stokes'] = True
		elif opt in ('-d', '--decimate'):
			config['freqDecimation'] = int(value, 10)
		elif opt in ('-l', '--limit'):
			config['lastFile'] = int(value, 10)
		elif opt in ('-s', '--split'):
			config['maxIntsInIDI'] = int(value, 10)
		elif opt in ('-t', '--tag'):
			config['outnameTag'] = value
		elif opt in ('-f', '--force'):
			config['force'] = True
		else:
			assert False
			
	# Add in arguments
	config['args'] = args
	
	# Validate
	if len(config['args']) == 0:
		raise RuntimeError("Must provide at least one .npz file to plot")
	if config['freqDecimation'] <= 0:
		raise RuntimeError("Invalid value for the frequency decimation factor")
	if config['lastFile'] <= 0 and config['lastFile'] != -1:
		raise RuntimeError("Invalid value for the last file to process")
		
	# Return configuration
	return config


def cmpNPZ(x, y):
	xDD = numpy.load(x)
	xT = xDD['tStart'].item()
	xDD.close()
	
	yDD = numpy.load(y)
	yT = yDD['tStart'].item()
	yDD.close()
	
	return cmp(xT, yT)


_SIMBAD_CACHE = {}
def getSourceName(src):
	"""
	Function to take a ephem.FixedBody() instance and resolve it to a name 
	using Simbad.  This function returns the most popular (highest citation
	count) name within 2" of the provided position.
	"""
	
	import urllib
	
	# Pull out what we know about the source
	name = src.name
	ra = str(src._ra)
	dec = str(src._dec)
	epoch = (src._epoch - ephem.J2000) / 365.25 + 2000.0
	epoch = str(epoch)
	
	# See if it is in the lookup cache
	try:
		name = _SIMBAD_CACHE[(ra, dec, epoch)]
		return name
		
	except KeyError:
		pass
		
	# If not, we need to query Simbad to find out what to call it
	try:
		## Query
		result = urllib.urlopen('http://simbad.u-strasbg.fr/simbad/sim-coo?Coord=%s&CooFrame=FK5&CooEpoch=%s&CooEqui=%s&CooDefinedFrames=none&Radius=2&Radius.unit=arcsec&submit=submit%%20query&CoordList=&output.format=ASCII' % (urllib.quote_plus('%s %s' % (ra, dec)), epoch, epoch))
		matches = result.readlines()
		
		## Parse
		rank = 0
		for line in matches:
			### Skip over blank lines, comments, and ASCII table headers
			if len(line) < 3:
				continue
			if line[0] in ('#', '-'):
				continue
				
			if line[:6] == 'Object':
				### Case 1: There is only one object within the search radius
				fields = line.split('---')
				name = fields[0].replace('Object', '')
				_SIMBAD_CACHE[(ra, dec, epoch)] = name
				break
			else:
				### Case 2: There are multiple objects and we need to parse 
				### each entry to get the name and the citation count.  Highest
				### citation count wins
				fields = line.split('|')
				if len(fields) < 13:
					continue
					
				if int(fields[-2], 10) > rank:
					name = fields[2].replace('NAME ', '')
					rank = int(fields[-2], 10)
					_SIMBAD_CACHE[(ra, dec, epoch)] = name
					
	except IOError:
		## Fall-through for errors that should default to the original
		## src.name
		pass
		
	except ValueError:
		## Fall-through for errors that should default to the original
		## src.name
		pass
		
	return name


def main(args):
	# Parse the command line
	config = parseConfig(args)
	
	filenames = config['args']
	filenames.sort(cmp=cmpNPZ)
	if config['lastFile'] != -1:
		filenames = filenames[:config['lastFile']]
	lownames = filter(lambda x: x.find('L-vis2') != -1, filenames)
	highnames = filter(lambda x: x.find('H-vis2') != -1, filenames)
	assert(len(lownames) == len(highnames))
	
	# Build up the station
	site = stations.lwa1
	observer = site.getObserver()
	
	# Load in the file file to figure out what to do
	dataDict = numpy.load(lownames[0])
	tStart = dataDict['tStart'].item()
	tInt = dataDict['tInt']
	
	freqL = dataDict['freq1']
	freq = freqL
	
	cConfig = dataDict['config']
	fh, tempConfig = tempfile.mkstemp(suffix='.txt', prefix='config-')
	os.close(fh)
	fh = open(tempConfig, 'w')
	for line in cConfig:
		fh.write('%s\n' % line)
	fh.close()
	refSrc, junk1, junk2, junk3, junk4, antennas = readCorrelatorConfiguration(tempConfig)
	os.unlink(tempConfig)
	
	visXX = dataDict['vis1XX'].astype(numpy.complex64)
	visXY = dataDict['vis1XY'].astype(numpy.complex64)
	visYX = dataDict['vis1YX'].astype(numpy.complex64)
	visYY = dataDict['vis1YY'].astype(numpy.complex64)
	dataDict.close()
	
	dataDict = numpy.load(highnames[0])
	freqH = dataDict['freq1']
	dataDict.close()
	
	if freqH[0] < freqL[0]:
		temp = freqH
		freqH = freqL
		freqL = temp
		
		temp = highnames
		highnames = lownames
		lownames = temp
		
	print "Antennas:"
	for ant in antennas:
		print "  Antenna %i: Stand %i, Pol. %i" % (ant.id, ant.stand.id, ant.pol)
		
	nChan = visXX.shape[1]
	blList = uvUtils.getBaselines([ant for ant in antennas if ant.pol == 0], IncludeAuto=True)
	
	if config['freqDecimation'] > 1:
		if nChan % config['freqDecimation'] != 0:
			raise RuntimeError("Invalid freqeunce decimation factor:  %i %% %i = %i" % (nChan, config['freqDecimation'], nChan%config['freqDecimation']))

		nChan /= config['freqDecimation']
		freq.shape = (freq.size/config['freqDecimation'], config['freqDecimation'])
		freq = freq.mean(axis=1)
	
	# Figure out the visibility conjugation problem in LSL, pre-1.1.4
	conjugateVis = False
	if float(fitsidi.__version__) < 0.9:
		print "Warning: Applying conjugate to visibility data"
		conjugateVis = True
		
	# Fill in the data
	for i,(lowname,highname) in enumerate(zip(lownames,highnames)):
		## Load in the integration - lower band
		dataDict = numpy.load(lowname)
		
		cConfig = dataDict['config']
		fh, tempConfig = tempfile.mkstemp(suffix='.txt', prefix='config-')
		os.close(fh)
		fh = open(tempConfig, 'w')
		for line in cConfig:
			fh.write('%s\n' % line)
		fh.close()
		refSrc, junk1, junk2, junk3, junk4, antennas = readCorrelatorConfiguration(tempConfig)
		refSrc.name = refSrc.name.upper()	# For AIPS
		if refSrc.name[:12] == 'ELWA_SESSION':
			## Convert ELWA_SESSION names to "real" source names
			refSrc.name = getSourceName(refSrc).replace(' ', '').upper()
		os.unlink(tempConfig)

		tStart = dataDict['tStart'].item()
		tInt = dataDict['tInt'].item()
		visXXL = dataDict['vis1XX'].astype(numpy.complex64)
		visXYL = dataDict['vis1XY'].astype(numpy.complex64)
		visYXL = dataDict['vis1YX'].astype(numpy.complex64)
		visYYL = dataDict['vis1YY'].astype(numpy.complex64)
		
		dataDict.close()
		
		## Load in the integration - upper band
		dataDict = numpy.load(highname)
		
		visXXH = dataDict['vis1XX'].astype(numpy.complex64)
		visXYH = dataDict['vis1XY'].astype(numpy.complex64)
		visYXH = dataDict['vis1YX'].astype(numpy.complex64)
		visYYH = dataDict['vis1YY'].astype(numpy.complex64)
		
		dataDict.close()
		
		## Combine
		visXX = numpy.concatenate([visXXL, visXXH], axis=1)
		visXY = numpy.concatenate([visXYL, visXYH], axis=1)
		visYX = numpy.concatenate([visYXL, visYXH], axis=1)
		visYY = numpy.concatenate([visYYL, visYYH], axis=1)
		
		if config['freqDecimation'] > 1:
			visXX.shape = (visXX.shape[0], visXX.shape[1]/config['freqDecimation'], config['freqDecimation'])
			visXX = visXX.mean(axis=2)
			visXY.shape = (visXY.shape[0], visXY.shape[1]/config['freqDecimation'], config['freqDecimation'])
			visXY = visXY.mean(axis=2)
			visYX.shape = (visYX.shape[0], visYX.shape[1]/config['freqDecimation'], config['freqDecimation'])
			visYX = visYX.mean(axis=2)
			visYY.shape = (visYY.shape[0], visYY.shape[1]/config['freqDecimation'], config['freqDecimation'])
			visYY = visYY.mean(axis=2)
			
		if conjugateVis:
			visXX = visXX.conj()
			visXY = visXY.conj()
			visYX = visYX.conj()
			visYY = visYY.conj()
			
		if config['circular'] or config['stokes']:
			visI = visXX + visYY
			visQ = visXX - visYY
			visU = visXY + visYX
			visV = (visXY - visYX) / 1.0j
			
			if config['circular']:
				visRR = visI + visV
				visRL = visQ + 1j*visU
				visLR = visQ - 1j*visU
				visLL = visI - visV
				
		if i % config['maxIntsInIDI'] == 0:
			## Clean up the previous file
			try:
				fits.write()
				fits.close()
			except NameError:
				pass
				
			## Create the FITS-IDI file as needed
			### What to call it
			if config['outnameTag'] is None:
				outname = 'buildIDI.FITS_%i' % (i/config['maxIntsInIDI']+1,)
			else:
				outname = 'buildIDI_%s.FITS_%i' % (config['outnameTag'], i/config['maxIntsInIDI']+1,)
				
			### Does it already exist or not
			if os.path.exists(outname):
				if not config['force']:
					yn = raw_input("WARNING: '%s' exists, overwrite? [Y/n] " % outname)
				else:
					yn = 'y'
					
				if yn not in ('n', 'N'):
					os.unlink(outname)
				else:
					raise RuntimeError("Output file '%s' already exists" % outname)
					
			### Create the file
			fits = fitsidi.IDI(outname, refTime=tStart)
			if config['circular']:
				fits.setStokes(['RR', 'RL', 'LR', 'LL'])
			elif config['stokes']:
				fits.setStokes(['I', 'Q', 'U', 'V'])
			else:
				fits.setStokes(['XX', 'XY', 'YX', 'YY'])
			fits.setFrequency(freqL)
			fits.setFrequency(freqH)
			fits.setGeometry(stations.lwa1, [a for a in antennas if a.pol == 0])
			print "Opening %s for writing" % outname

		if i % 10 == 0:
			print i
			
		## Update the observation
		observer.date = datetime.utcfromtimestamp(tStart).strftime('%Y/%m/%d %H:%M:%S.%f')
		refSrc.compute(observer)
		
		## Convert the setTime to a MJD and save the visibilities to the FITS IDI file
		obsTime = astro.unix_to_taimjd(tStart)
		if config['circular']:
			fits.addDataSet(obsTime, tInt, blList, visRR, pol='RR', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visRL, pol='RL', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visLR, pol='LR', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visLL, pol='LL', source=refSrc)
		elif config['stokes']:
			fits.addDataSet(obsTime, tInt, blList, visI, pol='I', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visQ, pol='Q', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visU, pol='U', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visV, pol='V', source=refSrc)
		else:
			fits.addDataSet(obsTime, tInt, blList, visXX, pol='XX', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visXY, pol='XY', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visYX, pol='YX', source=refSrc)
			fits.addDataSet(obsTime, tInt, blList, visYY, pol='YY', source=refSrc)
			
	# Cleanup the last file
	fits.write()
	fits.close()


if __name__ == "__main__":
	main(sys.argv[1:])
	
