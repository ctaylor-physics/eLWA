#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import numpy
import getopt
import tempfile
from datetime import datetime

from lsl.common import stations
from lsl.correlator import uvUtils
from lsl.reader import drx, vdif

from utils import *

from matplotlib import pyplot as plt


def usage(exitCode=None):
    print """plotUVCoverage.py - Plot the uv coverage in a collection of .npz files
generated by superCorrelator.py.

Usage:
plotUVCoverage.py [OPTIONS] npz [npz [...]]
Options:
-h, --help                  Display this help information
"""
    
    if exitCode is not None:
        sys.exit(exitCode)
    else:
        return True


def parseConfig(args):
    config = {}
    # Command line flags - default values
    config['args'] = []
    
    # Read in and process the command line flags
    try:
        opts, args = getopt.getopt(args, "h", ["help",])
    except getopt.GetoptError, err:
        # Print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage(exitCode=2)
        
    # Work through opts
    for opt, value in opts:
        if opt in ('-h', '--help'):
            usage(exitCode=0)
        else:
            assert False
            
    # Add in arguments
    config['args'] = args
    
    # Return configuration
    return config


def main(args):
    # Parse the command line
    config = parseConfig(args)
    filenames = config['args']
    
    # Build up the station
    site = stations.lwa1
    observer = site.getObserver()
    
    # Load in the file file to figure out what to do
    dataDict = numpy.load(filenames[0])
    tStart = dataDict['tStart'].item()
    tInt = dataDict['tInt']
    
    freq = dataDict['freq1']
    
    cConfig = dataDict['config']
    fh, tempConfig = tempfile.mkstemp(suffix='.txt', prefix='config-')
    fh = open(tempConfig, 'w')
    for line in cConfig:
        fh.write('%s\n' % line)
    fh.close()
    refSrc, junk1, junk2, junk3, readers, antennas = read_correlator_configuration(tempConfig)
    os.unlink(tempConfig)
    
    dataDict.close()
    
    # Prune down to a single polarization
    antennas = [ant for ant in antennas if ant.pol == 0]
    
    # Build up the list of baselines
    blList = uvUtils.getBaselines(antennas)
    
    # Loop through the files and do what we need to do
    t = []
    uvw = []
    for filename in filenames:
        ## Load in the integration
        dataDict = numpy.load(filename)
        
        tStart = dataDict['tStart'].item()
        tInt = dataDict['tInt'].item()
        
        dataDict.close()
        
        ## Update the observation
        observer.date = datetime.utcfromtimestamp(tStart).strftime('%Y/%m/%d %H:%M:%S.%f')
        refSrc.compute(observer)
        HA = (observer.sidereal_time() - refSrc.ra) * 12/numpy.pi
        dec = refSrc.dec * 180/numpy.pi
        
        ## Compute u, v, and w
        t.append( datetime.utcfromtimestamp(tStart) )
        uvw.append( uvUtils.computeUVW(antennas, HA=HA, dec=dec, freq=freq.mean(), site=observer) )
    uvw = numpy.array(uvw) / 1e3
    
    # Compute the baseline lengths
    blLength = numpy.sqrt( (uvw**2).sum(axis=2) )
    print len(blList), uvw.shape, blLength.shape
    
    # Report
    print "Phase Center:"
    print "  Name: %s" % refSrc.name
    print "  RA: %s" % refSrc._ra
    print "  Dec: %s" % refSrc._dec
    print "Antennas:"
    print "  Total: %i" % len(readers)
    print "  VDIF: %i" % sum([1 for rdr in readers if rdr is vdif])
    print "  DRX: %i" % sum([1 for rdr in readers if rdr is drx])
    print "Baselines:"
    print "  Total: %i" % (uvw.shape[0]*uvw.shape[1])
    ## Minimum basline length
    m = numpy.argmin(blLength)
    b = m % uvw.shape[1]
    bl0 = blList[b][0].stand.id
    if bl0 < 50:
        bl0 = 'EA%02i' % bl0
    else:
        bl0 = 'LWA%i' % (bl0-50)
    bl1 = blList[b][1].stand.id
    if bl1 < 50:
        bl1 = 'EA%02i' % bl1
    else:
        bl1 = 'LWA%i' % (bl1-50)
    print "  Minimum: %.2f klambda (%s <-> %s)" % (blLength.min(), bl0, bl1)
    print "  Median: %.2f klambda" % numpy.median(blLength)
    ## Maximum baseline length
    m = numpy.argmax(blLength)
    b = m % uvw.shape[1]
    bl0 = blList[b][0].stand.id
    if bl0 < 50:
        bl0 = 'EA%02i' % bl0
    else:
        bl0 = 'LWA%i' % (bl0-50)
    bl1 = blList[b][1].stand.id
    if bl1 < 50:
        bl1 = 'EA%02i' % bl1
    else:
        bl1 = 'LWA%i' % (bl1-50)
    print "  Maximum %.2f klambda (%s <-> %s)" % (blLength.max(), bl0, bl1)
    
    # Plot
    fig = plt.figure()
    ax = fig.gca()
    for i in xrange(uvw.shape[0]):
        l, = ax.plot(uvw[i,:,0], uvw[i,:,1], linestyle='', marker='o', ms=3.0, alpha=0.2)
        ax.plot(-uvw[i,:,0], -uvw[i,:,1], linestyle='', marker='o', ms=3.0, alpha=0.2, color=l.get_color())
    ax.set_xlabel('u [$k\\lambda$]')
    ax.set_ylabel('v [$k\\lambda$]')
    ax.set_title('%s\n%s to %s' % (refSrc.name, min(t).strftime("%m/%d %H:%M:%S"), max(t).strftime("%m/%d %H:%M:%S")))
    plt.show()


if __name__ == "__main__":
    main(sys.argv[1:])
    