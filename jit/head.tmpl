/*
 * Version Control Information - head.tmpl
 * 
 * $Rev$
 * $LastChangedBy$
 * $LastChangedDate$
 * 
 */

#include "Python.h"
#include <math.h>
#include <stdio.h>
#include <complex.h>
#include <cblas.h>
#include <fftw3.h>
#include <stdlib.h>

#ifdef _OPENMP
	#include <omp.h>
#endif

#include "numpy/arrayobject.h"

#define PI 3.1415926535898
#define TPI (2*3.1415926535898*_Complex_I)


/*
 Load in FFTW wisdom.  Based on the read_wisdom function in PRESTO.
*/

void read_wisdom(char *filename, PyObject *m) {
	int status = 0;
	FILE *wisdomfile;
	
	wisdomfile = fopen(filename, "r");
	if( wisdomfile != NULL ) {
		status = fftwf_import_wisdom_from_file(wisdomfile);
		PyModule_AddObject(m, "useWisdom", PyBool_FromLong(status));
		fclose(wisdomfile);
	} else {
		PyModule_AddObject(m, "useWisdom", PyBool_FromLong(status));
	}
}

{%- if useWindow -%}
/*
  Holder for window function callback
*/

static PyObject *windowFunc = NULL;
{%- endif %}


/*
  FFT shift function
*/

void fftshift(double *data) {
	double *temp;
	temp = (double *) malloc(sizeof(double) * ({{nChan}}/2+{{nChan}}%2));
	
	// Copy the postive frequencies over to the temporary location
	memcpy(temp, data, sizeof(double)*({{nChan}}/2+{{nChan}}%2));
	// Move the negative frequencies to the bottom half
	memmove(data, (data+{{nChan}}/2), sizeof(double)*{{nChan}}/2);
	// Copy the positive frequeices back in to the upper half
	memcpy((data+{{nChan}}/2), temp, sizeof(double)*({{nChan}}/2+{{nChan}}%2));
	
	free(temp);
}

void fftshiftf(float *data) {
	float *temp;
	temp = (float *) malloc(sizeof(float) * ({{nChan}}/2+{{nChan}}%2));
	
	// Copy the postive frequencies over to the temporary location
	memcpy(temp, data, sizeof(float)*({{nChan}}/2+{{nChan}}%2));
	// Move the negative frequencies to the bottom half
	memmove(data, (data+{{nChan}}/2), sizeof(float)*{{nChan}}/2);
	// Copy the positive frequeices back in to the upper half
	memcpy((data+{{nChan}}/2), temp, sizeof(float)*({{nChan}}/2+{{nChan}}%2));
	
	free(temp);
}

void cfftshift(double complex *data) {
	double complex *temp;
	temp = (double complex *) malloc(sizeof(double complex) * ({{nChan}}/2+{{nChan}}%2));
	
	// Copy the postive frequencies over to the temporary location
	memcpy(temp, data, sizeof(double complex)*({{nChan}}/2+{{nChan}}%2));
	// Move the negative frequencies to the bottom half
	memmove(data, (data+{{nChan}}/2), sizeof(double complex)*{{nChan}}/2);
	// Copy the positive frequeices back in to the upper half
	memcpy((data+{{nChan}}/2), temp, sizeof(double complex)*({{nChan}}/2+{{nChan}}%2));
	
	free(temp);
}

void cfftshiftf(float complex *data) {
	float complex *temp;
	temp = (float complex *) fftwf_malloc(sizeof(float complex) * ({{nChan}}/2+{{nChan}}%2));
	
	// Copy the postive frequencies over to the temporary location
	memcpy(temp, data, sizeof(float complex)*({{nChan}}/2+{{nChan}}%2));
	// Move the negative frequencies to the bottom half
	memmove(data, (data+{{nChan}}/2), sizeof(float complex)*{{nChan}}/2);
	// Copy the positive frequeices back in to the upper half
	memcpy((data+{{nChan}}/2), temp, sizeof(float complex)*({{nChan}}/2+{{nChan}}%2));
	
	fftwf_free(temp);
}


/*
  Complex magnitude squared functions
*/

double cabs2(double complex z) {
	return creal(z)*creal(z) + cimag(z)*cimag(z);
}

float cabs2f(float complex z) {
	return crealf(z)*crealf(z) + cimagf(z)*cimagf(z);
}


/*
  Function to compute the interger and fractional delays for a set of inputs
*/

long computeDelayComponents(PyArrayObject *delays, double SampleRate, long *fifo, double *frac) {
	long i, j;
	long fifoMax;
	double minDelay;
	
	// Set up a way to access the data
	double *a;
	a = (double *) delays->data;
	
	// Find the minimum delay
	/*
	minDelay = 1e9;
	for(i=0; i<{{nStand}}; i++) {
		for(j=0; j<{{nChan}}; j++) {
			if( *(a + {{nChan}}*i + j) < minDelay ) {
				minDelay = *(a + {{nChan}}*i + j);
			}
		}
	}
	*/
	minDelay = 0.0;
	
	// Compute the FIFO and fractional delays
	fifoMax = 0.0;
	for(i=0; i<{{nStand}}; i++) {
		*(fifo + i) = lround( (*(a + {{nChan}}*i + {{nChan}}/2) - minDelay) * SampleRate );
		if( *(fifo + i) > fifoMax) {
			fifoMax = *(fifo + i);
		}
		
		for(j=0; j<{{nChan}}; j++) {
			*(frac + {{nChan}}*i + j) = (*(a + {{nChan}}*i + j) - minDelay) - (double) *(fifo + i)/SampleRate;
		}
	}
	
	return fifoMax;
}

